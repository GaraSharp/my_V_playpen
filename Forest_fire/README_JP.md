# forest_fire.v

V termで動く、森林火災のシミュレーションですだよ。

## usage and dosage

`v forest_fire.v` でコンパイルすると、forest_fire というバイナリを生成します。

引数に、樹木の密度 (0〜1)を書くと、その密度によって平地に樹木を配置します。

例. 樹木を 0.5 (50%)の密度で配置して実行します。
```
$ ./forest_fire 0.5
```
## code structure 

森林火災のシミュレーションっぽい感じで、各セルの状態が、つぎのどれか、という具合に進行します。

- 平地 flat ; 白で表示
- 樹木 tree ; 緑で表示
- 火災 fire ; 赤で表示
- 鎮火 burn ; 黒で表示

ルールとしては、

1. 平地は一切影響を受けない
2. 樹木は、vonNeumann近傍に火災があれば、つぎの時点で火災になる
3. 火災は、つぎの時点で鎮火になる

という事で進められます。

コード全体の進行は、

1. 樹木密度をargument list から取得し、樹木の設置を乱数で行います。そして、中央に火災セルを設置
2. メインループ。フィールドの表示とセル集計/出力、フィールドの状態更新
3. 火災セルが0になるまで、ループ継続

ベースは、examples/game_of_life/life.v を拝借しておりますが、つぎの部分で変更を行っております。

- vonNeumann近傍の調査
- セルの色表示
- セル空間の集計と、ファイルへの出力

以下、各項目の説明。
### vonNeumann近傍の調査
life.v では、life game 進行のため、注目するセルの周囲8セルを調査します (Moore近傍)が、forest fire vでは、注目するセルの上下左右セルのみの調査(vonNeumann近傍)の調査を行いいます。
単純な2重ループでは却って面倒なので、配列による変位量の導入で解決しました。
### セルの色表示
セルの着色には、関数を用意して対処しましたが、termuxではflicker チラツキが起こる難点があります。今後の検討課題。
### セル空間の集計と、ファイルへの出力
セルの集計、平地は変化なしなので、樹木と火災、鎮火のセルをステージの度に集計します。集計のために、セル空間の構造体メンバを追加しました、集計のためのメンバ関数を呼び、結果をmain() で出力します。

## inside code

- & を付けない構造体はスタックに、& を付けてアクセスする構造体はヒープに、という違いを、今回、ようやく理解しました
- & を付けない構造体を作って返戻値とする関数では、関数内でメンバとなる変数を設置し、return Struct_name { member, member, ... } の様にする、というのがわかって、利用する事ができたのでした。
- セル集計したデータは data.dat に記録されます。後で gnuplot にてグラフを作るのに活用できるかも

## anatomie progressos ?

「樹木」が「火災」を経て「鎮火」に至るという過程自体は、未罹患、感染、回復の SIR モデルと同様の過程で、火災から鎮火の移行が1 step の、特殊 SIR モデルと言えそうです。
そのため、データ出力のグラフをplotすると、SIR モデルで観られるグラフと同様の図像が得られます。
化学反応の方面でも、こうした計算はあるそうで、つぎの連立微分方程式の解が、そうした曲線を示してくれるらしい。

$$
\frac {d}{dt} f(t) = -a \ f(t) 
$$

※ Obsidian で数式を表示できるというので、書いてみましたが、Markdown の仕様ではないので、github のreadme.md で表示できるかは不明

## ToDo

- [ ] V gg による書き換え
- [ ] コードの整理

いじょ

## Revision historica

- 2023-09-22
  first appearance
